<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Objetos</title>

  <p>Bienvenido a objetos</p>
  <script>

    /*     Build JavaScript Objects
    You may have heard the term object before.
    
    Objects are similar to arrays, except that instead of using indexes to access and modify their data, you access the data in objects through what are called properties.
    
    Objects are useful for storing data in a structured way, and can represent real world objects, like a cat.
    
            Here's a sample cat object: */

    const cat = {
      "name": "Whiskers",
      "legs": 4,
      "tails": 1,
      "enemies": ["Water", "Dogs"]
    };
    /* In this example, all the properties are stored as strings, such as name, legs, and tails.However, you can also use numbers as properties.You can even omit the quotes for single - word string properties, as follows: */

    const anotherObject = {
      make: "Ford",
      5: "five",
      "model": "focus"
    };
    /*       However, if your object has any non - string properties, JavaScript will automatically typecast them as strings. */

    /* Accessing Object Properties with Dot Notation:
    There are two ways to access the properties of an object: dot notation(.) and bracket notation([]), similar to an array.
    
    Dot notation is what you use when you know the name of the property you're trying to access ahead of time.
    
    Here is a sample of using dot notation(.) to read an object's property: */

    const myObj = {
      prop1: "val1",
      prop2: "val2"
    };

    const prop1val = myObj.prop1;
    const prop2val = myObj.prop2;
    /* prop1val would have a value of the string val1, and prop2val would have a value of the string val2.
  */
    // Setup
    const testObj = {
      "an entree": "hamburger",
      "my side": "veggies",
      "the drink": "water"
    };

    // Only change code below this line
    const entreeValue = testObj["an entree"];   // Change this line
    const drinkValue = testObj["the drink"];    // Change this line



    const b = {
      // es bueno usar const cuando creamos objetos, para evitar q un nuevo objeto cambie la referencia a este
    };
    console.log(b);

    // se puede crear objetos de la siguiente forma tambien

    const c = new Object(); // pero casi nadie utiliza esta estrcutura
    console.log(c);

    const fede = {
      nombre: "Fede", //va con coma en lugar de punto y coma
      apellido: "Irarrazaval",
      edad: 33,
      comportamiento: ["correr", "estudiar"],
      soltero: false, //puede tener todo tipo de datos
      contacto: {
        email: "fedeirar@gmail.com",
        cell: 1567887879  //hasta puede tener sus propios objetos
      },
      saludos: function () {
        console.log("HOLA!") //hasta le puedo agregar una funcion
      },
      decirMiNombre: function () {
        console.log(`Hola me llamo ${this.nombre} ${this.apellido} y tengo ${this.edad} anios y me podes llamar a ${this.contacto.cell}`) //this es el contexto en el que nos encontramos. This hace referencia al mismo objeto. De vos mismo, hace tal cosa
      }
    }
    console.log(fede); //con esto te imprime los datos
    console.log(fede["apellido"]); //con esto le digo q acceda a una propiedad especifica, en este caso el nombre.Los rectangulitos son las propiedades o los ATRIBUTOS.

    //Los atributos son variables q tiene un objeto. Las funciones no son atributos. Es un METODO.
    // a modo de ejemeplo, el .length es un atributo o propiedad de un objeto, su largo
    console.log(fede.nombre); //con esto te imprime el valor del atributo del objeto (variable)
    console.log(fede.comportamiento[1]);
    console.log(fede.contacto); //con esto imprime todos los atributos del objeto contacto que es un objeto de fede
    console.log(fede.contacto.email); //puede seleccionar incluso uno solo de los atributos del sub objeto
    fede.saludos(); //con esto invoco la funcion saludos de fede

    fede.decirMiNombre();

    // hay algunos metodo de object que es el prototipo u objeto de javascrip q tiene metodos importantes o utiles

    console.log(Object.keys(fede)); //es un metodo del Object q me permite listar todas las llaves de un objeto. Te lista los atributos y metodos

    console.log(Object.values(fede)); // esto es casi lo mismo q key pero te lista los valores, no los atributos. Los valores son los valores del atributo. El atributo seria como una variable

    console.log(fede.hasOwnProperty("nombre")); // esto te tira true si hay una propiedad en el objeto fede q sea nombre. Aca te tira true

    console.log(fede.hasOwnProperty("nacimiento")); // Aca te tira false

    /* Accessing Object Properties with Variables:
    Another use of bracket notation on objects is to access a property which is stored as the value of a variable.This can be very useful for iterating through an object's properties or when accessing a lookup table.
    
    Here is an example of using a variable to access a property: */

    const dogs = {
      Fido: "Mutt",
      Hunter: "Doberman",
      Snoopie: "Beagle"
    };

    const myDog = "Hunter";
    const myBreed = dogs[myDog];
    console.log(myBreed);
    /* The string Doberman would be displayed in the console.
    
    Another way you can use this concept is when the property's name is collected dynamically during the program execution, as follows: */

    const someObj = {
      propName: "John"
    };

    function propPrefix(str) {
      const s = "prop";
      return s + str;
    }

    const someProp = propPrefix("Name");
    console.log(someObj[someProp]);
    /* someProp would have a value of the string propName, and the string John would be displayed in the console.
        
        Note that we do not use quotes around the variable name when using it to access the property because we are using the value of the variable, not the name.
         */

    // Setup
    const testObj2 = {
      12: "Namath",
      16: "Montana",
      19: "Unitas"
    };

    // Only change code below this line
    const playerNumber = 16;  // Change this line
    const player = testObj2[playerNumber];   // Change this line


    /*     Updating Object Properties
    After you've created a JavaScript object, you can update its properties at any time just like you would update any other variable. You can use either dot or bracket notation to update.
    
    For example, let's look at ourDog: */

    const ourDog = {
      "name": "Camper",
      "legs": 4,
      "tails": 1,
      "friends": ["everything!"]
    };
    /* Since he's a particularly happy dog, let's change his name to the string Happy Camper.Here's how we update his object's name property: ourDog.name = "Happy Camper"; or ourDog["name"] = "Happy Camper"; Now when we evaluate ourDog.name, instead of getting Camper, we'll get his new name, Happy Camper. */

    /* Update the myDog object's name property. Let's change her name from Coder to Happy Coder.You can use either dot or bracket notation. */
    // Setup
    const myDog3 = {
      "name": "Coder",
      "legs": 4,
      "tails": 1,
      "friends": ["freeCodeCamp Campers"]
    };
    myDog3.name = "Happy Coder";
    // Only change code below this line

    /* Add New Properties to a JavaScript Object
    You can add new properties to existing JavaScript objects the same way you would modify them.
    
          Here's how we would add a bark property to ourDog: */

    ourDog.bark = "bow-wow";
    or

    ourDog["bark"] = "bow-wow";
    /* Now when we evaluate ourDog.bark, we'll get his bark, bow-wow.
    
        Example: */

    const ourDog = {
      "name": "Camper",
      "legs": 4,
      "tails": 1,
      "friends": ["everything!"]
    };

    /*     ourDog.bark = "bow-wow";
    Add a bark property to myDog and set it to a dog sound, such as "woof". You may use either dot or bracket notation. */

    const myDog3 = {
      "name": "Happy Coder",
      "legs": 4,
      "tails": 1,
      "friends": ["freeCodeCamp Campers"]
    };

    myDog3.bark = "woof";

    /*     Using Objects for Lookups:
    Objects can be thought of as a key / value storage, like a dictionary.If you have tabular data, you can use an object to lookup values rather than a switch statement or an if/else chain. This is most useful when you know that your input data is limited to a certain range.
    
    Here is an example of a simple reverse alphabet lookup: */

    const alpha = {
      1: "Z",
      2: "Y",
      3: "X",
      4: "W",
      /*   ... */
      24: "C",
      25: "B",
      26: "A"
    };

    alpha[2];
    alpha[24];

    const value = 2;
    alpha[value];
    /*      alpha[2] is the string Y, alpha[24] is the string C, and alpha[value] is the string Y. */

    /* Convert the switch statement into an object called lookup. Use it to look up val and assign the associated string to the result variable. */

    // Setup
    function phoneticLookup(val) {
      let result = "";

      // Only change code below this line
      const lookup = {
        alpha: "Adams",
        bravo: "Boston",
        charlie: "Chicago",
        delta: "Denver",
        echo: "Easy",
        foxtrot: "Frank",
      };
      return lookup[val];

      // Only change code above this line
      return result;
    }

    console.log(phoneticLookup("charlie")); // Chicago

    /* Testing Objects for Properties
  Sometimes it is useful to check if the property of a given object exists or not. We can use the .hasOwnProperty(propname) method of objects to determine if that object has the given property name. .hasOwnProperty() returns true or false if the property is found or not.
  
  Example */

    const myObj4 = {
      top: "hat",
      bottom: "pants",
    };

    myObj4.hasOwnProperty("top");
    myObj4.hasOwnProperty("middle");
    /* The first hasOwnProperty returns true, while the second returns false.
    
    Modify the function checkObj to test if an object passed to the function (obj) contains a specific property (checkProp). If the property is found, return that property's value. If not, return "Not Found". */

    function checkObj(obj, checkProp) {
      // Only change code below this line
      if (obj.hasOwnProperty(checkProp)) {
        return obj[checkProp];
      } else {
        return "Not Found";
      }

      // Only change code above this line
    }

    /*     Accessing Nested Objects:
    The sub - properties of objects can be accessed by chaining together the dot or bracket notation.
    
    Here is a nested object:
     */
    const ourStorage = {
      "desk": {
        "drawer": "stapler"
      },
      "cabinet": {
        "top drawer": {
          "folder1": "a file",
          "folder2": "secrets"
        },
        "bottom drawer": "soda"
      }
    };

    ourStorage.cabinet["top drawer"].folder2;
    ourStorage.desk.drawer;

    /*    ourStorage.cabinet["top drawer"].folder2 would be the string secrets, and ourStorage.desk.drawer would be the string stapler.
    
   Access the myStorage object and assign the contents of the glove box property to the gloveBoxContents variable.Use dot notation for all properties where possible, otherwise use bracket notation. */

    const myStorage = {
      "car": {
        "inside": {
          "glove box": "maps",
          "passenger seat": "crumbs"
        },
        "outside": {
          "trunk": "jack"
        }
      }
    };

    const gloveBoxContents = myStorage.car.inside["glove box"];
    /* 
        Accessing Nested Arrays:
    As we have seen in earlier examples, objects can contain both nested objects and nested arrays.Similar to accessing nested objects, array bracket notation can be chained to access nested arrays.
    
    Here is an example of how to access a nested array: */

    const ourPets = [
      {
        animalType: "cat",
        names: [
          "Meowzer",
          "Fluffy",
          "Kit-Cat"
        ]
      },
      {
        animalType: "dog",
        names: [
          "Spot",
          "Bowser",
          "Frankie"
        ]
      }
    ];

    ourPets[0].names[1];
    ourPets[1].names[0];
    ourPets[0].names[1] /* would be the string Fluffy, and ourPets[1].names[0] would be the string Spot.

Using dot and bracket notation, set the variable secondTree to the second item in the trees list from the myPlants object. */
    const myPlants = [
      {
        type: "flowers",
        list: [
          "rose",
          "tulip",
          "dandelion"
        ]
      },
      {
        type: "trees",
        list: [
          "fir",
          "pine",
          "birch"
        ]
      }
    ];

    const secondTree = myPlants[1].list[1]; //pine

    // Setup
    const recordCollection = {
      2548: {
        albumTitle: "Slippery When Wet",
        artist: "Bon Jovi",
        tracks: ["Let It Rock", "You Give Love a Bad Name"],
      },
      2468: {
        albumTitle: "1999",
        artist: "Prince",
        tracks: ["1999", "Little Red Corvette"],
      },
      1245: {
        artist: "Robert Palmer",
        tracks: [],
      },
      5439: {
        albumTitle: "ABBA Gold",
      },
    };

    // Only change code below this line
    function updateRecords(records, id, prop, value) {
      /*   records[id].tracks = [];
      records[id].tracks.push(value);
      return records[id]; */
      if (prop != "tracks" && value != "") {
        records[id][prop] = value;
      } else if (prop == "tracks" && records[id].hasOwnProperty(prop) == false) {
        records[id].tracks = [];
        records[id].tracks.push(value);
      } else if (prop == "tracks" && value !== "") {
        records[id].tracks.push(value);
      } else if (value == "") {
        delete records[id][prop];
      }
      return records;
    }

    console.log(updateRecords(recordCollection, 5439, "artist", "ABBA"));
/*



  </script>

</head>

<body>

</body>

</html>